//1-Practica escribir un predicado de prueba
// Esta función recibe una lista de strings y devuelve el primer string que 
//comienza con la letra "M" y que contiene la letra "a".
String  singlewhere ( Iterable < String > elementos) {
  devolver artículos. solteroDonde (
      (elemento) => elemento. comienza con ( 'M' ) && elemento. contiene ( 'a' ));
}


//2-Condiciones de comprobación
// Función que devuelve true si hay algún usuario menor de 18 años en la lista de
// usuarios
bool  anyUserUnder18 ( Iterable < Usuario > usuarios) {
  usuarios de retorno . cualquiera ((usuario) => usuario.edad <  18 );
}
// Función que devuelve true si todos los usuarios en la lista tienen más de 13 años
bool  everyUserOver13 ( Iterable < Usuario > usuarios) {
  usuarios de retorno . cada ((usuario) => usuario.edad >  13 );
}
// Clase que representa a un usuario
 usuario de clase {
  Nombre de cadena ;
  edad int ;
  // Constructor de la clase Usuario
  Usuario (
    this.nombre,
    this.edad,
  );

  //3-Filtrado de elementos de una lista

// Devuelve una iteración de los usuarios cuya edad es 21 o mayor.
Iterable < Usuario > filterOutUnder21 ( Iterable < Usuario > usuarios) {
  usuarios de retorno . donde ((usuario) => usuario.edad >=  21 );
}
// Devuelve una iteración de los usuarios con un nombre de longitud igual o menor a 3.
Iterable < Usuario > findShortNamed ( Iterable < Usuario > usuarios) {
  usuarios de retorno . donde ((usuario) => usuario.nombre.longitud <=  3 );
}
 usuario de clase {
  Nombre de cadena ; // El nombre del usuario.
  edad int ; // La edad del usuario.

  Usuario (
    este .nombre,
    esta edad,
  );
}
//4-Asignación a un tipo diferente
// Devuelve un iterable de cadenas que contienen el nombre y la edad de cada usuario en la lista
Iterable < String > getNameAndAges ( Iterable < User > usuarios) {
  usuarios de retorno . map ((usuario) =>  ' ${ usuario . nombre } es ${ usuario . edad } ' );
}
// La clase User representa a un usuario con un nombre y una edad
 usuario de clase {
  Nombre de cadena ;
  edad int ;
  // El constructor recibe un nombre y una edad y los asigna a los campos correspondientes
  Usuario ( este .nombre, esta .edad);
}

//5-Poniéndolo todo junto
// Recibe una Iterable de Strings y devuelve una Iterable de EmailAddress.
// Cada cadena se convierte en una dirección de correo electrónico.
Iterable < Dirección de correo electrónico > parseEmailAddresses ( Iterable < Cadena > cadenas) {
  cadenas de retorno . mapa ((s) =>  Dirección de correo electrónico (s));
}
// Recibe una Iterable de EmailAddress y devuelve un booleano.
// Devuelve true si alguna EmailAddress de la Iterable es inválido.
bool  anyInvalidEmailAddress ( Iterable < EmailAddress > correos electrónicos) {
  devolver correos electrónicos. any ((correo electrónico) =>  ! isValidEmailAddress (correo electrónico));
}
// Recibe una Iterable de EmailAddress y devuelve una Iterable de EmailAddress.
// Devuelve una Iterable que contiene sólo los EmailAddress válidos.
Iterable < Dirección de correo electrónico > direcciones de correo electrónico válidas ( Iterable < Dirección de correo electrónico > correos electrónicos) {
  devolver correos electrónicos. donde ((correo electrónico) =>  isValidEmailAddress (correo electrónico));
}
// La clase EmailAddress representa una dirección de correo electrónico.
// Contiene un String que representa la dirección de correo electrónico.
 dirección de correo electrónico de clase {
   dirección de cadena final ;
  // Constructor de la clase EmailAddress. Recibe un String que representa la dirección de correo electrónico.
  dirección de correo electrónico ( esta .dirección);
  // Sobrescribe el operador == para que dos EmailAddress sean iguales si tienen la misma dirección de correo electrónico.
  @anular
   operador  booleano == ( objeto otro) =>
      idéntico ( este , otro) ||
          otro es  dirección de correo electrónico  &&
              runtimeType == otro.runtimeType &&
              dirección == otra.dirección;
  // Sobrescribe el hashCode para que se base en la dirección de correo electrónico.
  @anular
  int  get hashCode => dirección.hashCode;
  // Sobrescribe el método toString para que muestre la dirección de correo electrónico.
  @anular
  Cadena  a Cadena () {
    return  'EmailAddress{dirección: $ dirección }' ;
  }
}
}
